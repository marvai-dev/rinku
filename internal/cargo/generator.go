// Package cargo generates Cargo.toml from Go dependencies.
package cargo

import (
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"

	"github.com/spf13/afero"
	"github.com/stephan/rinku/internal/gomod"
	"github.com/stephan/rinku/internal/types"
	urlpkg "github.com/stephan/rinku/internal/url"
)

type Lookup interface {
	Lookup(sourceURL, targetLang string, unsafe bool) []string
	CrateName(rustURL string) string
	RequiredDeps(sourceURL, targetLang string) []types.RequiredDep
}

type MappedDependency struct {
	GoDep        gomod.Dependency
	RustTargets  []string
	CrateNames   []string
	RequiredDeps []types.RequiredDep
}

type UnmappedDependency struct {
	GoDep gomod.Dependency
}

type GenerateResult struct {
	Mapped   []MappedDependency
	Unmapped []UnmappedDependency
}

func MapDependencies(deps []gomod.Dependency, lookup Lookup, unsafe bool) *GenerateResult {
	result := &GenerateResult{}
	for _, dep := range deps {
		ghURL := ModulePathToGitHubURL(dep.Path)
		rustURLs := lookup.Lookup(ghURL, "rust", unsafe)

		if len(rustURLs) > 0 {
			mapped := MappedDependency{GoDep: dep, RustTargets: rustURLs}
			for _, rustURL := range rustURLs {
				// Try configured crate name first, fall back to heuristic extraction
				crateName := lookup.CrateName(rustURL)
				if crateName == "" {
					crateName = ExtractCrateName(rustURL)
				}
				mapped.CrateNames = append(mapped.CrateNames, crateName)
			}
			// Collect required dependencies for this mapping
			mapped.RequiredDeps = lookup.RequiredDeps(ghURL, "rust")
			result.Mapped = append(result.Mapped, mapped)
		} else {
			result.Unmapped = append(result.Unmapped, UnmappedDependency{GoDep: dep})
		}
	}
	return result
}

var versionSuffixRe = regexp.MustCompile(`/v\d+$`)

func ModulePathToGitHubURL(path string) string {
	// golang.org/x/foo -> github.com/golang/foo
	if strings.HasPrefix(path, "golang.org/x/") {
		pkg := strings.TrimPrefix(path, "golang.org/x/")
		if idx := strings.Index(pkg, "/"); idx != -1 {
			pkg = pkg[:idx]
		}
		return "https://github.com/golang/" + pkg
	}

	if strings.HasPrefix(path, "github.com/") {
		return "https://" + versionSuffixRe.ReplaceAllString(path, "")
	}

	return "https://" + path
}

// ExtractCrateName extracts a crate name from a GitHub URL using heuristics.
// This is used as a fallback when no explicit crate name is configured.
func ExtractCrateName(githubURL string) string {
	normalized := urlpkg.Normalize(githubURL)

	parts := strings.Split(normalized, "/")
	if len(parts) < 3 || parts[0] != "github.com" {
		return ""
	}

	repoName := parts[2]
	// Handle subpaths like github.com/tokio-rs/tracing/tree/master/tracing-appender
	if len(parts) >= 5 && parts[3] == "tree" {
		repoName = parts[len(parts)-1]
	}

	// Common Rust repo conventions: -rs suffix, hyphens become underscores
	return strings.ReplaceAll(strings.TrimSuffix(repoName, "-rs"), "-", "_")
}

func sanitizeCrateName(name string) (string, bool) {
	if name == "" || strings.ContainsAny(name, "\n\r\"=[]{}") {
		return "", false
	}
	for _, r := range name {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') ||
			(r >= '0' && r <= '9') || r == '_' || r == '-') {
			return "", false
		}
	}
	return name, true
}

func GenerateCargoToml(w io.Writer, moduleName string, result *GenerateResult) error {
	fmt.Fprintln(w, "# Generated by rinku - https://github.com/marvai-dev/rinku")
	fmt.Fprintf(w, "# Original Go module: %s\n\n", moduleName)
	fmt.Fprintln(w, "[package]")
	fmt.Fprintln(w, `name = "converted_project"`)
	fmt.Fprintln(w, `version = "0.1.0"`)
	fmt.Fprintln(w, `edition = "2021"`)
	fmt.Fprintln(w, "\n[dependencies]")

	sort.Slice(result.Mapped, func(i, j int) bool {
		if len(result.Mapped[i].CrateNames) > 0 && len(result.Mapped[j].CrateNames) > 0 {
			return result.Mapped[i].CrateNames[0] < result.Mapped[j].CrateNames[0]
		}
		return false
	})

	// Track which crates we've already output to avoid duplicates
	outputCrates := make(map[string]bool)

	for _, mapped := range result.Mapped {
		n := min(len(mapped.CrateNames), len(mapped.RustTargets))
		for i := 0; i < n; i++ {
			if safeName, ok := sanitizeCrateName(mapped.CrateNames[i]); ok {
				fmt.Fprintf(w, "%s = \"*\"  # from %s -> %s\n",
					safeName, mapped.GoDep.Path, mapped.RustTargets[i])
				outputCrates[safeName] = true
			} else {
				fmt.Fprintf(w, "# WARNING: invalid crate name skipped for %s\n", mapped.GoDep.Path)
			}
		}
	}

	// Collect and deduplicate required dependencies
	requiredDeps := make(map[string]types.RequiredDep)
	for _, mapped := range result.Mapped {
		for _, dep := range mapped.RequiredDeps {
			if safeName, ok := sanitizeCrateName(dep.Crate); ok {
				if !outputCrates[safeName] {
					requiredDeps[safeName] = dep
				}
			}
		}
	}

	// Output required dependencies
	if len(requiredDeps) > 0 {
		// Sort for deterministic output
		var reqNames []string
		for name := range requiredDeps {
			reqNames = append(reqNames, name)
		}
		sort.Strings(reqNames)

		for _, name := range reqNames {
			dep := requiredDeps[name]
			if len(dep.Features) > 0 {
				fmt.Fprintf(w, "%s = { version = \"*\", features = [", name)
				for i, f := range dep.Features {
					if i > 0 {
						fmt.Fprint(w, ", ")
					}
					fmt.Fprintf(w, "%q", f)
				}
				fmt.Fprint(w, "] }")
			} else {
				fmt.Fprintf(w, "%s = \"*\"", name)
			}
			if dep.Reason != "" {
				fmt.Fprintf(w, "  # required: %s", dep.Reason)
			}
			fmt.Fprintln(w)
		}
	}

	if len(result.Unmapped) > 0 {
		fmt.Fprintln(w, "\n# TODO: Find equivalents for these Go dependencies:")
		for _, unmapped := range result.Unmapped {
			fmt.Fprintf(w, "# TODO: find equivalent for %s\n", unmapped.GoDep.Path)
		}
	}

	return nil
}

func WriteCargoTomlFS(fs afero.Fs, path string, moduleName string, result *GenerateResult) (err error) {
	file, err := fs.Create(path)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()
	return GenerateCargoToml(file, moduleName, result)
}
