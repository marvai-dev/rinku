// Generator for precompiled index
// Run with: go run ./cmd/generate
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/stephan/rinku/internal/types"
)

func main() {
	// Read libs.json
	libsData, err := os.ReadFile("libs.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading libs.json: %v\n", err)
		os.Exit(1)
	}

	var libsFile types.LibsFile
	if err := json.Unmarshal(libsData, &libsFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing libs.json: %v\n", err)
		os.Exit(1)
	}

	// Read mappings.json
	mappingsData, err := os.ReadFile("mappings.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading mappings.json: %v\n", err)
		os.Exit(1)
	}

	var mappingsFile types.MappingsFile
	if err := json.Unmarshal(mappingsData, &mappingsFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing mappings.json: %v\n", err)
		os.Exit(1)
	}

	// Build indexes
	result := BuildIndexes(libsFile.Libs, mappingsFile.Mappings)

	// Generate Go source file
	var sb strings.Builder
	sb.WriteString("// Code generated by cmd/generate. DO NOT EDIT.\n")
	sb.WriteString("package main\n\n")

	// Write forward index (enabled only)
	sb.WriteString("// index maps \"target_lang:normalized_source_url\" to target URLs (safe only)\n")
	sb.WriteString("var index = map[string][]string{\n")
	writeMap(&sb, result.Forward)
	sb.WriteString("}\n\n")

	// Write forward index (all entries including unsafe)
	sb.WriteString("// indexAll maps \"target_lang:normalized_source_url\" to target URLs (including unsafe)\n")
	sb.WriteString("var indexAll = map[string][]string{\n")
	writeMap(&sb, result.ForwardAll)
	sb.WriteString("}\n\n")

	// Write reverse index (enabled only)
	sb.WriteString("// reverseIndex maps \"source_lang:normalized_target_url\" to source URLs (safe only)\n")
	sb.WriteString("var reverseIndex = map[string][]string{\n")
	writeMap(&sb, result.Reverse)
	sb.WriteString("}\n\n")

	// Write reverse index (all entries including unsafe)
	sb.WriteString("// reverseIndexAll maps \"source_lang:normalized_target_url\" to source URLs (including unsafe)\n")
	sb.WriteString("var reverseIndexAll = map[string][]string{\n")
	writeMap(&sb, result.ReverseAll)
	sb.WriteString("}\n")

	// Write output file
	if err := os.WriteFile("index_gen.go", []byte(sb.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing index_gen.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated index_gen.go:\n")
	fmt.Printf("  Libraries: %d (%d unsafe)\n", result.LibrariesCount, result.UnsafeCount)
	fmt.Printf("  Mappings: %d\n", result.MappingsCount)
	fmt.Printf("  Forward index: %d entries (safe), %d entries (all)\n", len(result.Forward), len(result.ForwardAll))
	fmt.Printf("  Reverse index: %d entries (safe), %d entries (all)\n", len(result.Reverse), len(result.ReverseAll))
}

// writeMap writes a map to the string builder in sorted order
func writeMap(sb *strings.Builder, m map[string][]string) {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		targets := m[key]
		sb.WriteString(fmt.Sprintf("\t%q: {", key))
		for i, t := range targets {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(fmt.Sprintf("%q", t))
		}
		sb.WriteString("},\n")
	}
}
