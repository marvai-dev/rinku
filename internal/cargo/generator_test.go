package cargo

import (
	"bytes"
	"strings"
	"testing"

	"github.com/stephan/rinku/internal/gomod"
)

func TestModulePathToGitHubURL(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "simple github path",
			input: "github.com/spf13/cobra",
			want:  "https://github.com/spf13/cobra",
		},
		{
			name:  "github path with version suffix",
			input: "github.com/spf13/cobra/v2",
			want:  "https://github.com/spf13/cobra",
		},
		{
			name:  "golang.org/x package",
			input: "golang.org/x/crypto",
			want:  "https://github.com/golang/crypto",
		},
		{
			name:  "golang.org/x package with subpath",
			input: "golang.org/x/crypto/ssh",
			want:  "https://github.com/golang/crypto",
		},
		{
			name:  "other domain",
			input: "gopkg.in/yaml.v3",
			want:  "https://gopkg.in/yaml.v3",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ModulePathToGitHubURL(tt.input)
			if got != tt.want {
				t.Errorf("ModulePathToGitHubURL(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

func TestExtractCrateName(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "known crate - clap",
			input: "https://github.com/clap-rs/clap",
			want:  "clap",
		},
		{
			name:  "known crate - tokio",
			input: "https://github.com/tokio-rs/tokio",
			want:  "tokio",
		},
		{
			name:  "known crate - serde_json",
			input: "https://github.com/serde-rs/json",
			want:  "serde_json",
		},
		{
			name:  "unknown crate - heuristic",
			input: "https://github.com/owner/some-crate",
			want:  "some_crate",
		},
		{
			name:  "unknown crate with -rs suffix",
			input: "https://github.com/owner/mycrate-rs",
			want:  "mycrate",
		},
		{
			name:  "crate in subpath",
			input: "https://github.com/tokio-rs/tracing/tree/master/tracing-appender",
			want:  "tracing_appender",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ExtractCrateName(tt.input)
			if got != tt.want {
				t.Errorf("ExtractCrateName(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

// mockLookup is a test double for the Lookup interface.
type mockLookup struct {
	mappings map[string][]string
}

func (m *mockLookup) Lookup(sourceURL, targetLang string, unsafe bool) []string {
	key := targetLang + ":" + sourceURL
	return m.mappings[key]
}

func TestMapDependencies(t *testing.T) {
	lookup := &mockLookup{
		mappings: map[string][]string{
			"rust:https://github.com/spf13/cobra": {"https://github.com/clap-rs/clap"},
			"rust:https://github.com/gin-gonic/gin": {"https://github.com/tokio-rs/axum"},
		},
	}

	deps := []gomod.Dependency{
		{Path: "github.com/spf13/cobra", Version: "v1.8.0", Indirect: false},
		{Path: "github.com/gin-gonic/gin", Version: "v1.9.0", Indirect: false},
		{Path: "github.com/unmapped/lib", Version: "v1.0.0", Indirect: false},
	}

	result := MapDependencies(deps, lookup, false)

	if len(result.Mapped) != 2 {
		t.Errorf("Mapped count = %d, want 2", len(result.Mapped))
	}

	if len(result.Unmapped) != 1 {
		t.Errorf("Unmapped count = %d, want 1", len(result.Unmapped))
	}

	if result.Unmapped[0].GoDep.Path != "github.com/unmapped/lib" {
		t.Errorf("Unmapped[0].GoDep.Path = %q, want github.com/unmapped/lib", result.Unmapped[0].GoDep.Path)
	}
}

func TestGenerateCargoToml(t *testing.T) {
	result := &GenerateResult{
		Mapped: []MappedDependency{
			{
				GoDep:       gomod.Dependency{Path: "github.com/spf13/cobra", Version: "v1.8.0"},
				RustTargets: []string{"https://github.com/clap-rs/clap"},
				CrateNames:  []string{"clap"},
			},
			{
				GoDep:       gomod.Dependency{Path: "github.com/gin-gonic/gin", Version: "v1.9.0"},
				RustTargets: []string{"https://github.com/tokio-rs/axum"},
				CrateNames:  []string{"axum"},
			},
		},
		Unmapped: []UnmappedDependency{
			{GoDep: gomod.Dependency{Path: "github.com/unmapped/lib", Version: "v1.0.0"}},
		},
	}

	var buf bytes.Buffer
	err := GenerateCargoToml(&buf, "test-module", result)
	if err != nil {
		t.Fatalf("GenerateCargoToml() error = %v", err)
	}

	output := buf.String()

	// Check header
	if !strings.Contains(output, "# Generated by rinku") {
		t.Error("Output should contain rinku header")
	}

	// Check package section
	if !strings.Contains(output, "[package]") {
		t.Error("Output should contain [package] section")
	}

	// Check dependencies section
	if !strings.Contains(output, "[dependencies]") {
		t.Error("Output should contain [dependencies] section")
	}

	// Check mapped dependencies (should be sorted)
	if !strings.Contains(output, `axum = "*"`) {
		t.Error("Output should contain axum dependency")
	}
	if !strings.Contains(output, `clap = "*"`) {
		t.Error("Output should contain clap dependency")
	}

	// Check unmapped dependencies as TODO
	if !strings.Contains(output, "# TODO: find equivalent for github.com/unmapped/lib") {
		t.Error("Output should contain TODO for unmapped dependency")
	}
}
