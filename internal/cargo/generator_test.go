package cargo

import (
	"bytes"
	"strings"
	"testing"

	"github.com/spf13/afero"
	"github.com/stephan/rinku/internal/gomod"
	"github.com/stephan/rinku/internal/types"
)

func TestModulePathToGitHubURL(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "simple github path",
			input: "github.com/spf13/cobra",
			want:  "https://github.com/spf13/cobra",
		},
		{
			name:  "github path with version suffix",
			input: "github.com/spf13/cobra/v2",
			want:  "https://github.com/spf13/cobra",
		},
		{
			name:  "golang.org/x package",
			input: "golang.org/x/crypto",
			want:  "https://github.com/golang/crypto",
		},
		{
			name:  "golang.org/x package with subpath",
			input: "golang.org/x/crypto/ssh",
			want:  "https://github.com/golang/crypto",
		},
		{
			name:  "other domain",
			input: "gopkg.in/yaml.v3",
			want:  "https://gopkg.in/yaml.v3",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ModulePathToGitHubURL(tt.input)
			if got != tt.want {
				t.Errorf("ModulePathToGitHubURL(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

func TestExtractCrateName(t *testing.T) {
	// ExtractCrateName now only does heuristic extraction.
	// Known crate name lookups are handled by the Lookup interface.
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "simple repo name",
			input: "https://github.com/clap-rs/clap",
			want:  "clap",
		},
		{
			name:  "repo with -rs suffix in org",
			input: "https://github.com/tokio-rs/tokio",
			want:  "tokio",
		},
		{
			name:  "repo name becomes crate name",
			input: "https://github.com/serde-rs/json",
			want:  "json",
		},
		{
			name:  "hyphens become underscores",
			input: "https://github.com/owner/some-crate",
			want:  "some_crate",
		},
		{
			name:  "repo with -rs suffix stripped",
			input: "https://github.com/owner/mycrate-rs",
			want:  "mycrate",
		},
		{
			name:  "crate in subpath",
			input: "https://github.com/tokio-rs/tracing/tree/master/tracing-appender",
			want:  "tracing_appender",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ExtractCrateName(tt.input)
			if got != tt.want {
				t.Errorf("ExtractCrateName(%q) = %q, want %q", tt.input, got, tt.want)
			}
		})
	}
}

// mockLookup is a test double for the Lookup interface.
type mockLookup struct {
	mappings     map[string][]string
	crateNames   map[string]string
	requiredDeps map[string][]types.RequiredDep
}

func (m *mockLookup) Lookup(sourceURL, targetLang string, unsafe bool) []string {
	key := targetLang + ":" + sourceURL
	return m.mappings[key]
}

func (m *mockLookup) CrateName(rustURL string) string {
	if m.crateNames != nil {
		return m.crateNames[rustURL]
	}
	return ""
}

func (m *mockLookup) RequiredDeps(sourceURL, targetLang string) []types.RequiredDep {
	if m.requiredDeps != nil {
		key := targetLang + ":" + sourceURL
		return m.requiredDeps[key]
	}
	return nil
}

func TestMapDependencies(t *testing.T) {
	lookup := &mockLookup{
		mappings: map[string][]string{
			"rust:https://github.com/spf13/cobra": {"https://github.com/clap-rs/clap"},
			"rust:https://github.com/gin-gonic/gin": {"https://github.com/tokio-rs/axum"},
		},
	}

	deps := []gomod.Dependency{
		{Path: "github.com/spf13/cobra", Version: "v1.8.0", Indirect: false},
		{Path: "github.com/gin-gonic/gin", Version: "v1.9.0", Indirect: false},
		{Path: "github.com/unmapped/lib", Version: "v1.0.0", Indirect: false},
	}

	result := MapDependencies(deps, lookup, false)

	if len(result.Mapped) != 2 {
		t.Errorf("Mapped count = %d, want 2", len(result.Mapped))
	}

	if len(result.Unmapped) != 1 {
		t.Errorf("Unmapped count = %d, want 1", len(result.Unmapped))
	}

	if result.Unmapped[0].GoDep.Path != "github.com/unmapped/lib" {
		t.Errorf("Unmapped[0].GoDep.Path = %q, want github.com/unmapped/lib", result.Unmapped[0].GoDep.Path)
	}
}

func TestGenerateCargoToml(t *testing.T) {
	result := &GenerateResult{
		Mapped: []MappedDependency{
			{
				GoDep:       gomod.Dependency{Path: "github.com/spf13/cobra", Version: "v1.8.0"},
				RustTargets: []string{"https://github.com/clap-rs/clap"},
				CrateNames:  []string{"clap"},
			},
			{
				GoDep:       gomod.Dependency{Path: "github.com/gin-gonic/gin", Version: "v1.9.0"},
				RustTargets: []string{"https://github.com/tokio-rs/axum"},
				CrateNames:  []string{"axum"},
			},
		},
		Unmapped: []UnmappedDependency{
			{GoDep: gomod.Dependency{Path: "github.com/unmapped/lib", Version: "v1.0.0"}},
		},
	}

	var buf bytes.Buffer
	err := GenerateCargoToml(&buf, "test-module", result)
	if err != nil {
		t.Fatalf("GenerateCargoToml() error = %v", err)
	}

	output := buf.String()

	// Check header
	if !strings.Contains(output, "# Generated by rinku") {
		t.Error("Output should contain rinku header")
	}

	// Check package section
	if !strings.Contains(output, "[package]") {
		t.Error("Output should contain [package] section")
	}

	// Check dependencies section
	if !strings.Contains(output, "[dependencies]") {
		t.Error("Output should contain [dependencies] section")
	}

	// Check mapped dependencies (should be sorted)
	if !strings.Contains(output, `axum = "*"`) {
		t.Error("Output should contain axum dependency")
	}
	if !strings.Contains(output, `clap = "*"`) {
		t.Error("Output should contain clap dependency")
	}

	// Check unmapped dependencies as TODO
	if !strings.Contains(output, "# TODO: find equivalent for github.com/unmapped/lib") {
		t.Error("Output should contain TODO for unmapped dependency")
	}
}

func TestWriteCargoTomlFS(t *testing.T) {
	fs := afero.NewMemMapFs()

	result := &GenerateResult{
		Mapped: []MappedDependency{
			{
				GoDep:       gomod.Dependency{Path: "github.com/spf13/cobra", Version: "v1.8.0"},
				RustTargets: []string{"https://github.com/clap-rs/clap"},
				CrateNames:  []string{"clap"},
			},
		},
		Unmapped: []UnmappedDependency{
			{GoDep: gomod.Dependency{Path: "github.com/unmapped/lib", Version: "v1.0.0"}},
		},
	}

	err := WriteCargoTomlFS(fs, "Cargo.toml", "test-module", result)
	if err != nil {
		t.Fatalf("WriteCargoTomlFS() error = %v", err)
	}

	// Verify file exists
	exists, err := afero.Exists(fs, "Cargo.toml")
	if err != nil {
		t.Fatalf("failed to check file existence: %v", err)
	}
	if !exists {
		t.Fatal("Cargo.toml was not created")
	}

	// Read and verify content
	content, err := afero.ReadFile(fs, "Cargo.toml")
	if err != nil {
		t.Fatalf("failed to read Cargo.toml: %v", err)
	}

	output := string(content)

	if !strings.Contains(output, "[package]") {
		t.Error("Output should contain [package] section")
	}

	if !strings.Contains(output, "[dependencies]") {
		t.Error("Output should contain [dependencies] section")
	}

	if !strings.Contains(output, `clap = "*"`) {
		t.Error("Output should contain clap dependency")
	}
}

func TestWriteCargoTomlFS_NestedPath(t *testing.T) {
	fs := afero.NewMemMapFs()

	result := &GenerateResult{
		Mapped: []MappedDependency{
			{
				GoDep:       gomod.Dependency{Path: "github.com/foo/bar", Version: "v1.0.0"},
				RustTargets: []string{"https://github.com/owner/crate"},
				CrateNames:  []string{"crate"},
			},
		},
	}

	// Create nested directory
	if err := fs.MkdirAll("output/rust", 0755); err != nil {
		t.Fatalf("failed to create directory: %v", err)
	}

	err := WriteCargoTomlFS(fs, "output/rust/Cargo.toml", "nested-module", result)
	if err != nil {
		t.Fatalf("WriteCargoTomlFS() error = %v", err)
	}

	// Verify file exists at nested path
	exists, _ := afero.Exists(fs, "output/rust/Cargo.toml")
	if !exists {
		t.Fatal("Cargo.toml was not created at nested path")
	}
}
